### 一. Algorithm
本周做的是 [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/)。判断链表是否有环，如果有的话返回环的起点，否则返回 null。

最开始想到的还是用容器实现，时间复杂度为 O(n) 同时需要额外的容器空间，空间复杂度最快情况下也为 O(n)。代码如下:

```
class Solution {

    public ListNode detectCycle(ListNode head) {

        if (head == null || head.next == null || head.next.next == null) {
            return null;
        }

        HashSet<ListNode> set = new HashSet<>();
        while (head != null) {
            if (set.contains(head)) {
                return head;
            }
            set.add(head);
            head = head.next;

        }
        return null;
    }
}
```

然后想到的方法是双重循环，从 head 往下移动，每移动一次判断是否有环，当移动过起点后环就会断开，此时可判断出起点的位置，但逻辑略复杂并且时间复杂度为 O(N^2)。然后是看了 discuss 部分中的答案才知道的，可以先通过快慢指针查出环中的节点。想到的另一种方法是，对于其实节点其特殊之处在于链表中有两个节点的 next 指向它，那么只需要判断两个 next 相同的节点并且不是同一个节点，则其 next 就是起点，但实际执行的过程依然超时，当链表增大时其判断次数可能会非常大。

实在想不出了看的 discuss，其提供了下面的算法:

```
public class Solution {
    public ListNode detectCycle(ListNode head) {

                ListNode slow = head;
                ListNode fast = head;
        
                while (fast!=null && fast.next!=null){
                    fast = fast.next.next;
                    slow = slow.next;
                    if (fast == slow){
                        ListNode slow2 = head; 
                        while (slow2 != slow){
                            slow = slow.next;
                            slow2 = slow2.next;
                        }
                        return slow;
                    }
                }
                return null;
    }
}
```

先通过快慢指针查出环中的节点，然后 slow 节点继续遍历，同时从 head 开始遍历遍历，直到与 node 相遇即为起点，一开始怎么也想不明白原因，评论区有给了一个 YouTube 上的一篇讲解，提到了 ```Floyd's cycle detection algorithm ``` 算法，简单来说遍历时 head 节点到达 begin 节点时 slow 节点一定也到达 begin 节点。视频是一位印度友人做的，虽然一口浓重的咖喱味英语，但并不是很难听懂，墙裂推荐，既适合学算法，也适合练英语，油管上已经两万多订阅啦，哈哈和耗子叔的专栏人数差不多。网址在这 [Vivekanand Khyade - Algorithm Every Day
](https://www.youtube.com/channel/UCx-kFfzekMbhODaBss-ZnsA) 


### 二. Review

本次读的是耗子叔练级攻略中推荐的一篇文章: [Writing Code that Scales](https://blog.rackspace.com/writing-code-that-scales), 作者分享了一些概念和技巧，帮助我们写出高可用、高扩展的代码。

首先作者提到了当你构建应用时需要注意的 5 个地方:

#### 1. 尽可能降低资源消耗

尽管现在的 CPU、内存、带宽和磁盘性能与容量都较之以前得到了大幅度提升，但最有效的利用资源的方式还是在每次操作中尽可能的少占用资源，最需要注意的想是下面四点:

- IO 性能: 包括磁盘 IO 、[BUS 总线 IO](https://zh.wikipedia.org/zh-hans/%E6%80%BB%E7%BA%BF) 等
- 网络带宽
- 内存占用
- CPU 的使用

#### 2. 通过并行计算解决瓶颈

将任务运行在多个 CPU 内核上，使用不同的网络和磁盘，甚至部署在不同的服务器上，这样使整体处理能力得到提高，同时保持数据的同步性，然后用锁保证并发性。

#### 3. 分布式数据存储

传统的将数据存储在单一的数据节点上方式，随着数据量的增大，其数据的读写性能会越来越低，数据存储节点会很快成为系统的瓶颈。但如果将数据分割存储在不同的节点之上，就可以很有效的环节随着数据量增大带来的性能问题。作者推荐 [Cassandra](http://cassandra.apache.org/) 等分布式数据存储系统来分散数据，提升总的数据存储容量和读写性能。

#### 4. 最终一致性

当应用允许某些旧数据可以暂时依然生效，然后在很短时间内能够将数据及时更新的话，可以考虑采用最终一致性的策略而不是强一致性。这样可以使得应用更加的灵活。但在决定方案时要仔细考虑数据对 ACID 特性的要求。

#### 5. 水平扩展优于垂直扩展

所谓垂直扩展就是不断增大单台机器的配置，从而保证性能。但是单台机器的配置永远不是无限的，随着数据量的增大，用户访问的增多，总有一天会达到瓶颈。因此相比于垂直扩展，作者更推送水平扩展，通过提供更多的服务器组成集群。这样虽然每一台服务器的单台性能可能都比不上原来的那一台服务器，但整个集群的可用性、容量都优于原来的单台服务器，并且会分散压力，提升整体性能。

但此时要注意几点:

-  Concurrency! = Locks: 减少锁的使用，即减少同步处理数据的情况，将任务变为异步。否则会造成阻塞，降低资源的使用效率。
- Thread per Connection = Bad: 作者强调了线程过多是非常不可取的，我们知道线程过多会导致线程切换消耗大量的资源，一般来说线程数与 CPU 核数一致是比较好的选择
- Thread Pool with Fixed Number of Workers = Good: 既然线程数过多是非常不好的，作者非常建议提供一个固定数量的线程池，当然，这个线程池的线程数也是可以进行修改的。这样可以减低线程创建销毁、过多线程切换带来的资源消耗。


列举了上面 5 个需要注意的地方后，作者有给出了如下几点建议帮助我们进一步构建高扩展的应用:

- 提前规划压力性能测试
- 使用 memcached、Redis 等构建分布式缓存，提升读取性能
- 压缩传输数据: 通过压缩数据可以减少网络传输的耗时，虽然会消耗 CPU 进行压缩和加压，但这是值得的
- 数据压缩存储: 压缩的意义在于降低 IO 的消耗
- 优化查询，查询的 IO 操作是大部分性能问题的瓶颈所在，尽可能减少随机 IO 的情况
- 降低内存消耗: 在内存已经确定的情况下，每次链接消耗的内存越小，我们可以并发的数量越多
- 谨慎使用文本格式: 虽然 json 和 XML 格式的文本非常便于解析，但文本解析过程非常消耗资源，因此更建议使用二进制数据格式进行传输


### 三. Tip

最近没有编程技巧方面的积累，本周 Tip 缺省。。。


### 四. Share

简单分享一下本周自习时对学习的一些反思和想法。

长期来看，拥有快速高效的学习能力是比单纯掌握某个技术知识点更重要的事情，而具体到学习层面，
学习可以分解为三个方面: 学习的内容、学习的方法、学习的结果，更简单来说就是学什么、怎么学、学习效果如何。下面针对这三方面谈下自己的想法

#### 一. 学什么

互联网时代堪称知识大爆炸时代，对于身处互联网行业从事技术工作的程序员们来说体会可能更加深刻。同时身在职场，又不像学生时代那样有充分的时间取学习。学习内容的增加、学习时间的减少，此时将不多的学习时间投入到哪方面的学习上就显得尤为重要。合适的学习内容使我们受益良多，不合适的内容可能会使我们白费时间，徒增疲劳。

有两种知识是非常值得我们重点去学习的：

##### 【1】 历久弥新的基础性知识

拿 IT 技术来说，应用技术不断发展，新的语言，新的框架与开源工具不断出现，但最开始的计算机科学相关的内容却基本没变。常用的数据结构、算法、计算机与操作系统的原理、Linux 各种特性、编写优雅代码的原则方法、数据库的索引原理、ES 的倒排索引原理等，这些知识无论技术如何发展，版本如何迭代，都不会产生大的变化。掌握了这些知识就相当于修炼了程序员的「九阳神功」，对于我们学习新知识大有裨益，最直观的一点就是减少了我们在学习新知识的意外因素。不知道是否有同学和我有相似的体验，在学习 A 时发现还需要用到 B 的知识，而 B 又可能需要别的知识，最后整个学习过程大大超过我们的预期，导致学习兴趣下降，最后不了了之。这也体现了知识是互相关联的特点。将基础知识掌握扎实，就如同在浩瀚的知识中建立起一个基本的网络体系，以后无论遇到何种新的知识都可以在这个体系中找到对应的位置，然后将其添加上去，随着知识体系的丰富，我们学习新知识的速度也会越来越快。

##### 【2】可积累的有长期收益的知识

知识也可以按照是否有可积累性划分，像英语、写作、演讲、逻辑思维能力等，这些随着掌握程度的加深，会带给我们越来越大的收益，用比较流行的一个概念就是这些是可以让我们产生 「复利」的知识。而像单纯掌握某个 应用 API 就很难带来复利，因为这些都是长久不用就会忘的知识。记得之前有段时间在啃 《Python Cookbook》 这本书，现在书中的内容大部分都忘了，现在回想起来确实有点不需要，因为整本书更适合放在案头当做一个手册随时查询某个 API 的使用，而不是花大段时间去学习然后遗忘。

#### 二. 怎么学

确定了学习哪些内容，接下来就是如何学的问题了。简单总结一点就是 ***做到极致的主动***。有个更流行的说法是 「刻意练习」，但我觉得刻意练习表达的没这强烈。怎么算极致的主动呢，举两个例子:

对于英语的学习，很多人强调多听多读的重要性，但很多时候我们在听读的时候真的只是听读，并没有尝试着去理解，自以为我明明整天带着耳机听了很多读了很多啊，但其实是自我欺骗罢了。更有效的方式是说和写，在精简点，一个词 ***「造句」***。一句话，作为英文原句读出来，听的懂和自己能将汉语正确无误的用英语表达出来有着本质的不同。例如下面的句子:

> He can not only speak English very well but also French.
> 他不仅英文说得好，而且还会说法语。

我相信这句话大多数过四级的同学都会看懂，也明白这里 ```not only ... but also  ``` 的含义，但如果是让自己说，或者用 ```not only ... but also  ``` 造句，真正能正确无误写对的可能就寥寥无几。如果我们主动去练习，去造句写作，然后纠正错误，不断改进，其学习效果肯定会比单纯的听读有效。

另外一个最近也有很多同学和我一样，在耗子叔的要求下做 ARTS 刷 LeetCode 算法题，但怎样才能收获最大呢？单纯做完提交代码通过就可以了吗？自己之前就是这种刷题方式，但近 20 道题下来其实收获并不大。更有效的方式是: 做完后提交通过，然后分析性能、时空复杂度，看是否有可改进的空间，并给出明确的改进理由，然后还可以去查看那些性能排名最靠前的算法实现，了解他们的思路和自己的思路作对比，最后看这道算法题用到哪方面的数据结构算法知识，是用到了二分查找还是快速排序，动态规划、DFS 还是使用了双向链表，然后将相关的知识回想一遍。这样下来做一道题目的时间将会大大增加，但我相信收获的会比单纯的刷更多的题目来的更多。

上面两个例子，就是自己所说的极致的主动，在可掌控范围内逼自己去做可能是最难，最容易受挫但可能也是收获最大的事，这并不容易做到。所以其实成功的路上并不拥挤，只需要努力一点就行了对么。


#### 三. 学完后如何

史蒂芬柯维在 《高效能人士的七个习惯》中提到了一个很重要的习惯 ***以终为始***。对于学习就是如果我们学完了，我们要达到怎样的水平，做出怎样的产品来，也就是要有明确的目标。这个对于学习非常重要，有这明确的目标可以使我们聚焦的方向，集中最大的精力全力以赴的学习。

比如之前在学习 ES 的过程中，自己最开始的目标就是，快速入门，搭建一套公司可用的 ELK 日志监控报警系统，当系统请求出现大量 499、502 返回时及时发送报警短信，针对这个目标开始将重点放在了 ES 集群管理、日志收集与存储以及报警工具的调研搭建上。现在系统搭建好了又有了新的目标: ES 的分片与 Lucene 倒排索引原理是什么、分布式存储机制、倒排索引的查询机制是怎样的又是如何影响查询性能的，全面了解 ES 的底层原理，针对 ES 的使用能在理解原理层面的基础之上给出使用中优化的建议和理由。

其他的方式，比如学完后可以尝试一个小白(比如测试妹子)讲一遍，用博客讲解一遍，在讲解的过程中我们很可能发现自己原本以为理解的地方其实并没有完全掌握，此时在接受反馈不断改进，学习才能事半功倍。


OK，以上就是自己的一些想法。最近关于学习方面自己思考了很多，中间遇到一个比较抑郁的问题: 「***最近公司切换阿里云后，发现阿里云的 RDS 做的挺不错的，除了基本功能外，各种监控都非常全面，对于慢查询、数据库事故等还会给出故障报告和优化建议，很多时候只需要照着做就行了，整体而言不需要有多么高的数据库水平，这几天同事一起吐槽"要啥 DBA 啊"，正好最近在看 《MySQL 技术内幕(InnoDB 存储引擎)》这本书，说实话还是有点波澜的，偶尔会有学了没用的感觉，不知道其他同学有没用过类似的感触，对于云服务做了大量的工作解放程序员这种情况又是如何看待的呢***|
