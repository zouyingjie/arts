### 一. Algorithm

继续做 DFS 相关的题目，本次做的是 [695. Max Area of Island](https://leetcode.com/problems/max-area-of-island/)，
题目本身是 [200. Number of Islands](https://leetcode.com/problems/number-of-islands/) 的改编版，题目要求：

- 由 1 组成的为陆地，1 的个数代表陆地的区域大小
- 找出区域最大的陆地

解决题目的思路还是利用 DFS 进行深度遍历，同时每次遍历时都要计算当前陆地的区域数量。

```Java
class Solution {
    private int[][] grid;
    private int row;
    private int column;
    private int maxCount = 0;
    private int currentCount = 0;

    public int maxAreaOfIsland(int[][] grid) {
        this.grid = grid;
        this.row = grid.length;
        if (row == 0) {
            return row;
        }
        this.column = grid[0].length;

        for (int i = 0; i < row; i++) {
            for (int j = 0; j < column; j++) {
                if (grid[i][j] == 1) {
                    dfs(i, j);
                    maxCount = Math.max(currentCount, maxCount);
                    currentCount = 0;
                } else {
                    continue;
                }

            }
        }
        return maxCount;
    }


    private void dfs(int i, int j) {

        if (i >= row || j >= column | i < 0 | j < 0) {
            return;
        }
        if (grid[i][j] == 1) {
            currentCount += 1;
            grid[i][j] = 0;
            dfs(i + 1, j);
            dfs(i - 1, j);
            dfs(i, j + 1);
            dfs(i, j - 1);
        }

    }
}
```

所有的节点都会被遍历到，时间复杂度应该 0(N)，实际提交执行时间 2ms，beats 100%，一次提交通过，总算有点进步的感觉了= = 



### 二. Review



http://highscalability.com/blog/2013/5/13/the-secret-to-10-million-concurrent-connections-the-kernel-i.html


### 三. Tips

最近在学习极客时间专栏 《Linux 性能优化实战》，分享下内存篇的脑图笔记：

![](https://github.com/zouyingjie/arts/blob/master/image/%E3%80%8ALinux%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E3%80%8B-%E5%86%85%E5%AD%98%E7%AF%87%E7%AE%80%E8%AE%B0.png)

### 四. Share

