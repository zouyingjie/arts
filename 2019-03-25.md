### 一. Algorithm

继续做 DFS 相关的题目，本次做的是 [695. Max Area of Island](https://leetcode.com/problems/max-area-of-island/)，
题目本身是 [200. Number of Islands](https://leetcode.com/problems/number-of-islands/) 的改编版，题目要求：

- 由 1 组成的为陆地，1 的个数代表陆地的区域大小
- 找出区域最大的陆地

解决题目的思路还是利用 DFS 进行深度遍历，同时每次遍历时都要计算当前陆地的区域数量。实现代码如下：

```Java
class Solution {
    private int[][] grid;
    private int row;
    private int column;
    private int maxCount = 0;
    private int currentCount = 0;

    public int maxAreaOfIsland(int[][] grid) {
        this.grid = grid;
        this.row = grid.length;
        if (row == 0) {
            return row;
        }
        this.column = grid[0].length;

        for (int i = 0; i < row; i++) {
            for (int j = 0; j < column; j++) {
                if (grid[i][j] == 1) {
                    dfs(i, j);
                    maxCount = Math.max(currentCount, maxCount);
                    currentCount = 0;
                } else {
                    continue;
                }

            }
        }
        return maxCount;
    }


    private void dfs(int i, int j) {

        if (i >= row || j >= column | i < 0 | j < 0) {
            return;
        }
        if (grid[i][j] == 1) {
            currentCount += 1;
            grid[i][j] = 0;
            dfs(i + 1, j);
            dfs(i - 1, j);
            dfs(i, j + 1);
            dfs(i, j - 1);
        }

    }
}
```

所有的节点都会被遍历到，时间复杂度应该 0(N)，实际提交执行时间 2ms，beats 100%，一次提交通过，总算有点进步的感觉了= = 


### 二. Review



http://highscalability.com/blog/2013/5/13/the-secret-to-10-million-concurrent-connections-the-kernel-i.html


### 三. Tips

最近在学习极客时间专栏 《Linux 性能优化实战》，分享下内存篇的脑图笔记：

![](https://github.com/zouyingjie/arts/blob/master/image/%E3%80%8ALinux%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E3%80%8B-%E5%86%85%E5%AD%98%E7%AF%87%E7%AE%80%E8%AE%B0.png)

### 四. Share

最近读到一个很有启发的观念：

> 现实生活中我们往往追求怎么变得更好，更成功，但是往往忽略了如何去规避失败。

这句话也可以拓展开来：

> 在想要变好之前，怎么做才能防止变得更坏。
> 在明确应该做什么之前，先明确应该不做什么。

个人觉得这句话对人生的意义比那些帮助你更好生活的建议更加的有意义。一般来说社会阶层的分布是符合正太分布的，极度富有成功、极度贫困失败的人只占极少数一部分，大部分芸芸众生其实都生活在一个差不多的水平线上，一个人想要提高自己的社会阶层可能具有较大的随机性，受到努力、机遇、环境甚至政策、家境等各方面因素的影响，因此在显著提高社会阶层的可能性具有很大不确定性的情况下，思考如何使自己的社会阶层不进一步的降低就显得非常有意义。一个是尽可能的提高上限，一个是提高下限。

具体到生活，比如理财，使我们更富有的方式有各种投资等，那么如何做使我们不至于陷入更加贫穷的地步呢？可以是减少消费来提高财富积累，可以是为自己买份保险(我真不是在推销保险= = )保证意外发生时自己可以有一定的风险承担能力，不至于因病返贫，因意外返贫等。

在比如学习，在明确哪些可以提高学习效率之前，先明确哪些会影响你的学习效率，分心、被打断、刷朋友圈等，那么可以先着手将这些干扰因素降到最低，然后再去采用其他方法去改进学习效率。
