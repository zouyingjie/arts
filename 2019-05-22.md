### 一. Algorithm


继续做买卖股票的题目，这次是[123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)，这也是比较难的一道了，题目也是要求买卖股票的最大利润，但是交易次数最多为两次。

首先想到的就是分治求解了，第一道题目中我们已经完成了求一个区间中只交易一次的最大收益，这道题就是从 0 开始，每次都将数据分成两个区间，分别求最大值后相加即可，实现代码如下：

```Java
public class Solution {
    
    public int maxProfit(int[] prices) {

        int len = prices.length;
        if (len <= 1) {
            return 0;
        }

        int result = 0;

        for (int i = 1; i < len; i ++) {
            if (i == (len-1)) {
                 result = Math.max(result, getProfit(prices, 0, i));
            }else {
                result = Math.max(result, getProfit(prices, 0, i) + getProfit(prices, i+1, len-1));
            }
            

        }

        return result;

    }

    // 买卖股票第一题中已经实现的算法
    public int getProfit(int[] prices, int start, int end) {
        int result = 0;

        int lowestPrice = prices[start];

        for (int i = start+1; i <= end; i ++) {
            if (prices[i] > lowestPrice) {
                result = Math.max(result, prices[i] - lowestPrice);
            }else {
                lowestPrice = prices[i];
            }
        }
        return result;

    }
}
```

通过分治的方法计算，时间复杂度为 O(N^2)，效率是比较低的，因此需要进一步的优化。

第二种解法是看了 discuss 部分学到的一种比较取巧的解法，因为最多交易两次，因此遍历到任意一天时都会存在四种状态

- 第一次买入
- 第一次卖出
- 第二次买入
- 第二次卖出

那么我们要做的就是每次遍历求这四个状态时的最大受益值，最终返回 sell2 即为最大收益，实现代码如下：

```Java
public class Solution {
    
    public int maxProfit(int[] prices) {

     int len = prices.length;
        if (len <= 1) {
            return 0;
        }

        // 开始计算 sell 的值其实是没有买入情况的，因此设置起始值为无限小
        // 为 0 的话那么最开始的 sell 计算就会等于遍历到的值，出现没有买入就有收益的情况。
        int buy1 = Integer.MIN_VALUE;
        int buy2 = Integer.MIN_VALUE;

        int sell1 = 0;
        int sell2 = 0;

        for (int i = 0; i < len; i++) {

            // sell2 的利润等于 buy2 + 当前值。即后一次的操作要依赖前一次操作的值
            // 因此计算顺序依次为 sell2、buy2、sell1、buy1。
            sell2 = Math.max(sell2, buy2 + prices[i]);
            buy2 = Math.max(buy2, sell1 - prices[i]);
                
            sell1 =Math.max(sell1, buy1 + prices[i]);
            buy1 = Math.max(buy1, -prices[i]);

        }

        return sell2;
    }   
}
```

这样遍历依次就可以求出最大收益值，时间复杂度为 O(N)。

### 二. Review

读 微软云服务设计模式可用性第三篇：![Throttling pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/throttling)。
### 三. Tips

本周使用 Python requests 库通过 https 请求又拍云图片时报错：

```
SSLError: HTTPSConnectionPool(host='xxx.xxx', port=443): Max retries exceeded with url: /fc31518057ee674ee6df30dfcfb3cac4 (Caused by SSLError(CertificateError("hostname 'xxx.cn' doesn't match '*.xx.upaiyun.com'",),))
```

搜索了一下发现很多人都遇到过这个问题，就是 SSL 证书验证失败。有下面几种解决方案。

#### 1. 方案一：跳过校验

算是一种最野路子的解决方式，代码如下：

```Python
url = "https://xxx.xxx"
requests.get(url,verify=False)
```

这并不是根本解决方案，但是当服务出现问题时可以先通过该方式及时的恢复服务，保证服务的可用性，后续再从根本上解决问题。

#### 2. 升级 Python 或者安装库

这个问题非常常见以至于 requests 的官方文档中给出了解释：

> "hostname doesn't match" 错误是怎么回事？
> 当 SSL certificate verification 发现服务器响应的认证和它认为自己连接的主机名不匹配时，就会发生这样的错误。如果你确定服务器的 SSL 设置是正确的（例如你可以用浏览器访问页面）> ，而且你使用的是 Python 2.6 或者 2.7，那么一个可能的解释就是你需要 Server-Name-Indication。

> Server-Name-Indication 简称 SNI，是一个 SSL 的官方扩展，其中客户端会告诉服务器它连接了哪个主机名。当服务器使用虚拟主机（ Virtual Hosting）时这点很重要。这样的服务器会服> 务多个 SSL 网站，所以它们需要能够针对客户端连接的主机名返回正确的证书。

> Python 3 和 Python 2.7.9+ 的 SSL 模块包含了原生的 SNI 支持。更多关于在 Request、SNI 以及 Python < 2.7.9 的信息请参见这个 [Stack Overflow 答案](https://stackoverflow.com/questions/18578439/using-requests-with-tls-doesnt-give-sni-support/18579484#18579484)。

结合文档和 Stack Overflow 中的答案，引发该问题的原因有两个：

- Python 版本过低
- 缺少库

因此解决方案也就有如下两种：

- 升级 Python 版本，这是最根本的解决方式
- 如果你的 Python 版本低于 Python 2.7.9+ 并且因为某些原因不能升级的话，那么就需要安装下面两个库：

```
pip install pyopenssl
pip install idna
```

安装后就可以正常访问了。


### 四. Share