### 一. Algorithm

做了 [538. Convert BST to Greater Tree](https://leetcode.com/problems/convert-bst-to-greater-tree/) 转换二叉查找树的题目。题目要求为转换后，原节点的值等于原节点与所有有比改节点值大的节点之和。

解决问题的关键还是要找出转换的规则:

- 对于根节点以及其最右侧子节点，其值等于该节点的值加上其所有右子节点
- 对于其余的右子节点，其值等于自身值 + 右子树节点之和 + 其父节点的父节点值之和
- 对于其余左子节点，值等于自身值 + 右子树节点之和 + 父节点的值

那么抽象出最终的转换规则就是:


> 节点值 = 自身值 + 右子树之和 + val

val 根据节点不同有三种规则

- 根节点在内的最右侧节点: 0
- 其他节点的左子节点: 父节点值
- 其他节点的右子节点: 父节点的父节点值


```Java
class Solution {
    
    public TreeNode convertBST(TreeNode root) {
    	 // 根节点为 的 val 为 0
        helper(root, 0);
        return root;
    }

    private int helper(TreeNode node, int val) {
        if (node == null) {
            return val;
        }
        // 首先计算右子树，
        node.val += helper(node.right, val);
        // 当前节点计算出后，在计算左子树，因此传入父节点的值
        // 而对于该节点的右子节点，则是父节点的父节点，符合我们的规则
        return helper(node.left, node.val);

    }
}

```

最终时间复杂度为 O(N)，整个算法从最右子节点开始计算，不需要额外的空间，因此空间复杂度为 O(1)。

另外做了 [543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/), 计算二叉树中两个距离最远节点的距离。本质上就是求某个节点左右子树高度之和的最大值。

思路是先计算每个节点到叶节点的最大高度，然后计算其左右子节点的高度之和，最大值即为所求的值，实现起来先用深度遍历计算了每个节点的高度，然后用 在进行一次遍历计算高度之和，实现代码如下:

```Java
public class Solution {

    private int result = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        calculateNodeHight(root);
        calculateDiameter(root);
        return result;
    }

    private int calculateNodeHight(TreeNode node) {
        if (node == null) {
            return 0;
        }
        int right = 0;
        int left = 0;
        if (node.right != null) {
            right =  1 + calculateNodeHight(node.right);
        }else {
            right = 0;
        }

        if (node.left != null) {
            left =  1 + calculateNodeHight(node.left);
        }else {
            left = 0;
        }

        node.val = Math.max(right, left);
        return node.val;
    }

    private void calculateDiameter(TreeNode node) {
        if (node == null) {
            return;
        }

        int right = 0;
        if (node.right != null) {
            right = node.right.val + 1;
        }

        int left = 0;
        if (node.left != null) {
            left = node.left.val + 1;
        }
        result = Math.max(left+right, result);
        calculateDiameter(node.left);
        calculateDiameter(node.right);
    }
}

```

只是在原二叉树上操作，因此空间复杂度为 O(N)，每次遍历都需要访问每个节点，遍历两次时间复杂度为 O(2N)，忽略系数还是为 O(N)。

### 二. Review

继续阅读耗子叔推荐的 NGINX 的微服务相关系列文章，本期是第二篇构建微服务的网关[Building Microservices: Using an API Gateway](https://www.nginx.com/blog/building-microservices-using-an-api-gateway/)。

文章拿 亚马逊的一个界面作为例子，当我们请求亚马逊购物网站的一个界面时，我们可能需要获取如下数据:

- 商品详情
- 购物车商品数量
- 商品评论
- 库存信息
- 配送地址选项
- 推荐信息
- 可替代商品

当我们使用单体服务时，可以通过一个或多个 API 请求来获取到这些数据然后渲染界面。当服务拆分为微服务后，就需要请求不同的服务了，文中将单体服务拆分如下:

![](https://cdn.wp.nginx.com/wp-content/uploads/2016/04/Richardson-microservices-part2-2_microservices-client.png)

如图所示，其将服务拆分为了如下几个微服务:

- 购物车服务
- 库存服务
- 推荐服务
- 订单服务
- 评论服务
- 产品类别服务
- 运送信息服务

拆分完成后，客户端有两种访问方式:***直接访问***和***网关访问***， 下面来看下两种方式的优劣。


#### 1. 客户端直接请求各个微服务

理论上来说，通过客户端直接访问到对应服务的负载均衡节点，最后请求到对应的服务实例是可行的，但是这种方式有三个问题：

-  性能较差: 如果某个界面或者功能需要访问的微服务过多，导致客户端需要发送非常多的请求，此时会极大的影响性能。
-  协议问题: 不同微服务之间的访问协议可能存在区别，有点是基于 RPC 协议，有点则是 AMQP 消息机制，而这些都是适合在服务器内部之间通信的不是对客户端友好的协议，客户端应该使用 HTTP 或者 websocket 等协议。
-  重构困难: 直接访问的方式客户端需要将指定的功能访问指定的微服务，此时如果后端发生重构，进行微服务的合并或者再次拆分，客户端也需要跟着做相应的修改，导致前后端依赖过重。

基于此，一般微服务的访问都采用网关模式进行访问。

#### 2. 使用 API 网关

微服务的网关模式，类似于设计模式中的外观模式(Facade Pattern)，其将客户端与具体的微服务解耦，充当两者之间的媒介，网关可以实现请求路由、权限校验、请求监控、负载均衡、缓存等功能。客户端通过网关访问微服务示例如下:

![](https://cdn.wp.nginx.com/wp-content/uploads/2016/04/Richardson-microservices-part2-3_api-gateway.png)

### 四. Share

分享下之前学习英语句型时整理的思维导图，学英语，核心就是发音和造句:

![](https://github.com/zouyingjie/arts/blob/master/image/%E8%8B%B1%E8%AF%AD%E4%BA%94%E5%A4%A7%E5%8F%A5%E5%9E%8B.png?raw=true)

