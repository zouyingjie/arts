### 一. Algorithm

做了 [538. Convert BST to Greater Tree](https://leetcode.com/problems/convert-bst-to-greater-tree/) 转换二叉查找树的题目。题目要求为转换后，原节点的值等于原节点与所有有比改节点值大的节点之和。

解决问题的关键还是要找出转换的规则:

- 对于根节点以及其最右侧子节点，其值等于该节点的值加上其所有右子节点
- 对于其余的右子节点，其值等于自身值 + 右子树节点之和 + 其父节点的父节点值之和
- 对于其余左子节点，值等于自身值 + 右子树节点之和 + 父节点的值

那么抽象出最终的转换规则就是:


> 节点值 = 自身值 + 右子树之和 + val

val 根据节点不同有三种规则

- 根节点在内的最右侧节点: 0
- 其他节点的左子节点: 父节点值
- 其他节点的右子节点: 父节点的父节点值


```Java
class Solution {
    
    public TreeNode convertBST(TreeNode root) {
    	 // 根节点为 的 val 为 0
        helper(root, 0);
        return root;
    }

    private int helper(TreeNode node, int val) {
        if (node == null) {
            return val;
        }
        // 首先计算右子树，
        node.val += helper(node.right, val);
        // 当前节点计算出后，在计算左子树，因此传入父节点的值
        // 而对于该节点的右子节点，则是父节点的父节点，符合我们的规则
        return helper(node.left, node.val);

    }
}

```

最终时间复杂度为 O(N)，整个算法从最右子节点开始计算，不需要额外的空间，因此空间复杂度为 O(1)。

另外做了 [543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/), 计算二叉树中两个距离最远节点的距离。本质上就是求某个节点左右子树高度之和的最大值。

思路是先计算每个节点到叶节点的最大高度，然后计算其左右子节点的高度之和，最大值即为所求的值，实现起来先用深度遍历计算了每个节点的高度，然后用 在进行一次遍历计算高度之和，实现代码如下:

```Java
public class Solution {

    private int result = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        calculateNodeHight(root);
        calculateDiameter(root);
        return result;
    }

    private int calculateNodeHight(TreeNode node) {
        if (node == null) {
            return 0;
        }
        int right = 0;
        int left = 0;
        if (node.right != null) {
            right =  1 + calculateNodeHight(node.right);
        }else {
            right = 0;
        }

        if (node.left != null) {
            left =  1 + calculateNodeHight(node.left);
        }else {
            left = 0;
        }

        node.val = Math.max(right, left);
        return node.val;
    }

    private void calculateDiameter(TreeNode node) {
        if (node == null) {
            return;
        }

        int right = 0;
        if (node.right != null) {
            right = node.right.val + 1;
        }

        int left = 0;
        if (node.left != null) {
            left = node.left.val + 1;
        }
        result = Math.max(left+right, result);
        calculateDiameter(node.left);
        calculateDiameter(node.right);
    }
}

```

只是在原二叉树上操作，因此空间复杂度为 O(N)，每次遍历都需要访问每个节点，遍历两次时间复杂度为 O(2N)，忽略系数还是为 O(N)。

### 二. Review

继续阅读耗子叔推荐的 NGINX 的微服务相关系列文章，本期是第二篇构建微服务的网关[Building Microservices: Using an API Gateway](https://www.nginx.com/blog/building-microservices-using-an-api-gateway/)。

文章拿 亚马逊的一个界面作为例子，当我们请求亚马逊购物网站的一个界面时，我们可能需要获取如下数据:

- 商品详情
- 购物车商品数量
- 商品评论
- 库存信息
- 配送地址选项
- 推荐信息
- 可替代商品

当我们使用单体服务时，可以通过一个或多个 API 请求来获取到这些数据然后渲染界面，当服务拆分为微服务后，就需要请求不同的服务了，此时有两种方式

#### 1. 客户端直接请求各个微服务

如图所示，我们可以让客户端直接去访问各个微服务:

![](https://cdn.wp.nginx.com/wp-content/uploads/2016/04/Richardson-microservices-part2-2_microservices-client.png)


#### 2. 使用 API 网关

### 四. Share

分享两个自己之前做的脑图笔记，一个是 《SQL 必知必会》的学习笔记，一个是英语五大句型的笔记。

