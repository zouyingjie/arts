### 一. Algorithm

本次做了 [739. Daily Temperatures](https://leetcode.com/problems/daily-temperatures/)。给予一个数组，对于一个元素，查出与比该元素大的第一个元素的相差的位置。首先想到的是双重遍历，查出每个差值，代码如下:

```
class Solution {
     public int[] dailyTemperatures(int[] T) {

        int length = T.length;
        int[] result = new int[length];
         
        int days = 0;
        for (int i = 0; i < length - 1; i ++) {
            for (int j = i + 1; j < length; j ++) {
                days ++;
                if (T[j] > T[i]) {
                    result[i] = days;
                    break;
                }
            }
            days = 0;
        }
        return result;

    }
}
```

如果给出的数组是完全降序，最坏情况下时间复杂度为O(N^2), 提交时运行时间为 300 多ms。

然后就是查找相关资料可以使用栈来实现时间复杂度为 O(N) 的操作，基本思路是先将每个索引入栈，在遍历后续的元素时，如果该元素比栈中索引对应的元素大，则将该索引出栈，并计算两个索引的差值。这样每个元素在循环时会访问一次，然后在栈操作时还会判断一次，时间复杂度为 O(N)，代码如下:

```Java
class Solution {
     public int[] dailyTemperatures(int[] T) {

       Stack<Integer> stack = new Stack();

        int length = T.length;

        int[] result = new int[length];

        for (int i = 0; i < length; i ++) {

            while (!stack.empty() && T[i] > T[stack.peek()]) {
                int index = stack.pop();
                result[index] = i - index;
            }
            stack.push(i);
        }
        return result;


    }
}
```

### 二. Review

本周读了一篇 FileBeat 相关的文章: [5 Filebeat Pitfalls To Be Aware Of](https://logz.io/blog/filebeat-pitfalls/)。

Filebeat 是 ELK 技术栈中用来收集日志文件的工具，是用 Go 语言写的，因此性能非常高，逐渐替代了 Logstash-forawrd 成为了日志收集的主要工具。虽然 FileBeat 比较简单易用，但也存在一些容易被忽略的问题。文章主要讲了如下 5 个使用 FileBeat 时需要注意的问题:

---

#### 1. YAML 配置

FileBeat 使用 YAML 格式的文件作为配置文件，因此和其他使用 Yaml 文件作为配置文件的软件一样，会因为 YAML 配置的语法出现错误。

YAML 文件本身对缩进和结构有比较严格的要求，有时候一个错误的缩进就可能导致整个应用无法使用，因此在配置时务必要谨慎细致。关于 YAML 配置的问题，作者推荐了另一篇文章 [Musings in YAML – Tips for Configuring Your Beats](https://logz.io/blog/configuring-elasticsearch-beats/) 供作参考。
 

#### 2. Registry File   

FileBeat 为了保证不丢失数据，会将每个要收集的文件的读取信息记录到 Registry File   中。如果出现短时间内创建大量日志文件的情况，那么向 Registry File 中记录的信息会急剧增加，从而占用过高的内存空间，影响软件和服务器的性能，因此在使用时要注意避免类似的情况。

另外 FileBeat 也提供了 ***clean_removed*** 配置项，当日志文件被删除时，其在 Registry File 中的信息也会被删除，从而节省空间。关于该配置的信息参见文档:[Configure FileBeat](https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-log.html)。

#### 3. 删除或者重命名文件时释放资源

当文件被删除或者重命名时，FileBeat 依然会保留对该文件的追踪，即依然占用着服务器资源，随着文件数量的增多，久而久之占用的资源就会越来越大，影响性能。为了解决该问题，需要用到 ***close_inactive*** 和 ***closed_removed*** 配置项。简介如下:

- close_inactive: 按照一定的时间间隔检查文件是否有改动，如果没有则结束对该文件的读取，释放资源，默认 5 分钟。
- closed_removed: 当文件被移除时，结束对该文件的读取，释放资源。

通过上述两个配置项，可以释放资源，更详细的解释参阅文档:[Configure FileBeat](https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-log.html)。

#### 4. 多个文件源

FileBeat 本身允许我们配置多个文件路径，如下:

```
- type: log
  enabled: false
  paths:
    - /var/log/*.log

- type: log
  enable: true
  tags: ['nginx', 'p1', 'access']
  paths:
    - /var/log/nginx/*.p1.access.log
  fields:
     log_topic: nginx

- type: log
  enable: true
  tags: ['nginx', 'p2', 'access']
  paths:
    - /var/log/nginx/*.p2.access.log
    - /var/log/nginx/*.p2.access.log.1
  fields:
     log_topic: nginx
```

虽然方便，但是当我们想追踪某一类文件时就会很麻烦，因此建议对每一类文件配置，都加一个type 或者 tag 以便于之后的进行区分。

##### 5. CPU 的使用

因为是 Go 语言编写的，FileBeat 的整体性能是非常高的，很少出现占用过高 CPU 的情况，当有一种情况可能会造成 CPU 占用的上升: FileBeat 对于每个 log 配置都可以通过配置项 ***scan_frequency*** 来设置读取文件的频率，默认是 10s, 官方文档中提示不建议小于 1s。当设置的读取文件过多，并且读取频率过于频繁时就会造成问题，实际使用中要避免这种情况。

以上就是文章主要提到的内容，总体而言 FileBeat 的使用还是非常简单的，不过随着 ES 的普及，FileBeat 的使用也会增多，因此多了解一些相关的细节和问题也是非常有必要的。


### 三. Tips

### 四. Share