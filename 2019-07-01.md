### 一. Algorithm

做了 [108. Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/) 和 [109. Convert Sorted List to Binary Search Tree](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/) 两道题目。

第 108 道题目是给出一个升序数组，然后根据该数组构建出一棵高度平衡的二叉查找树，二叉查找树的特点我们知道：

> 书中的任意一个节点，其左子节点的值都要小于该节点，其右子节点的值都要大于该节点的值。

高度平衡指的是：

> 每个节点的两个子树的深度从不相差超过1。 

那么回到题目，数组是升序的，并且要求高度平衡，那么我们必须从数组中间开始遍历，这样中间元素左边的就是其左子树，右边的就是其右子树，对于左右子树也是采用相同逻辑递归即可：

***问题分解与递归条件***

- 数组的中间元素作为根节点，左右两边元素作为左右子树的节点。对于左右两边元素依然可以采用相同的求解。如图所示：

![](https://github.com/zouyingjie/arts/blob/master/image/arts48_a.png)

***终止条件***

- 数组没有元素就返回空

整理实现代码如下：

```Java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {

        int len = nums.length;

        return findRoot(0, len-1, nums);


    }

    // 采用坐标区间来标识数组范围
    private TreeNode findRoot(int start, int end, int[] nums) {
        
        if(start > end){
            return null;
        }

        // 数组只有一个元素了，则返回为根节点，其左右子节点均为 null
        if (start == end) {
            return new TreeNode(nums[start]);
        }

        // 找到中间元素作为根节点
        int rootIndex = 0;
        if (end - start == 1) {
            rootIndex = end;
        }else {
             rootIndex = (int) Math.ceil( ((double) end + start) / 2);
        }

        int val = nums[rootIndex];

        TreeNode node = new TreeNode(val);

        // 左子节点就是当前数组 [0, index -1]，index 为根节点索引
        node.left = findRoot(start, rootIndex - 1, nums);
        // 右子节点就是当前数组 [index + 1, len - 1]
        node.right = findRoot(rootIndex + 1, end , nums);
        return node;
    }
}

```

第 106 道题目是 105 的进阶版，其数据源是一个升序的链表，然后转成高度平衡的二叉查找树。一种最暴力的方式是先将链表转为数组，然后用 105 的方式搞定。但出题人肯定是不希望我们用这种方式的。回到上面的题目，整个递归过程，每次递归变化的都是索引，因此哪怕换成了链表，数组的用索引，那么链表该用什么呢 -- 指针！

链表题目有三宝：

- 遍历
- 反转
- 快慢指针

遍历和反转显然没法帮我们找到链表中间节点的，那么唯一的选择就是快慢指针了。解题思路如下：

- 每次利用快慢指针遍历链表，快指针达到末尾时，慢指针就到达了中间节点。

如图分别是链表个数为奇数和偶数时的遍历情况，注意的是当链表长度为偶数时，最终的根节点是 ``slow.next``.

![](https://github.com/zouyingjie/arts/blob/master/image/arts_48_a_02.png)

实现代码如下：

```Java
class Solution {
      
    public TreeNode sortedListToBST(ListNode head) {

        return this.findRoot(head, null);

    }

    private TreeNode findRoot(ListNode head, ListNode tail) {

        if (head == tail) {
            return null;
        }

        ListNode fast = head;
        ListNode slow = head;

        while (fast != tail && fast.next != tail) {
            slow = slow.next;
            fast = fast.next.next;
        }
        
        TreeNode node = new TreeNode(slow.val);
        node.left = findRoot(head, slow);
        node.right = findRoot(slow.next , tail);
        return node;

    }
}
```

### 二. Review

读了一篇比较系统监控 APM 方式与日志管理方式的文章：![PM vs. Log Management: How Logging and Monitoring are Different & Why You Need Both](https://sematext.com/blog/apm-vs-log-management/#toc-what-is-apm-0)。 下面是文章的简单概要：

当你部署管理一个应用时，可以通过两种方式来帮助你确保程序满足可用性和高性能的预期：

- APM：程序性能管理(或监控)，全称是 Application Performance Management，也有的地方称为 Application Performance Monitoring。
- Log Management：日志管理分析。

#### 1. 什么是 APM？

简单的说，APM 是确保应用保持可用和及时响应的艺术。从更广义的角度看，APM 也可以帮助我们进行代码优化和降低基础设施成本。APM 工具可以通过监控各项指标来实现如下目标：

- 监控应用的可用性
- 监控服务的响应速度
- 监控服务的 CPU、内存、带宽等资源占用情况。

APM 的实现一般包含了多种不同的技术和方法。基于不同的 APM 工具和要实现的特性，我们的 APM 实现可以有如下一些操作：


- 真实用户监控 (RUM)：通过真实的用户数据来评估应用的健康状况。RUM(Real User Monitoring) 是一种针对数字业务的监控技术，通过查看在线用户如何与网站或者应用进行交互来分析用户的数字体验。分析内容包括从页面加载到 Ajax 请求以及前端应用程序崩溃的所有内容。关于 RUM 相关内容可以参阅这几篇文章:[What is Real User Monitoring](https://sematext.com/blog/what-is-real-user-monitoring/)、[RUM vs. APM: How They’re Similar and Different](https://sematext.com/blog/rum-vs-apm/)、[5 Best Practices for Real User Monitoring](https://sematext.com/blog/5-best-practices-for-getting-the-most-out-of-rum/)。

- 综合监控，依赖于合成交互来监控应用程序。（这一段自己没搞明白具体啥意思。。。）

- 网络监控: 可以通过分析网络传输情况来监控应用的可用性与性能。
- 分布式追踪: 可以帮助我们实现代码级别的跨应用监控。关于细节可以参考[OpenTracing Overview: Distributed Tracing’s Emerging Industry Standard](https://sematext.com/blog/opentracing-distributed-tracing-emerging-industry-standard/)。

鉴于可以有多种方式实现 APM，因此我们可以将 APM 看做一个管理程序的可用性和性能的综合策略，而不是一个单独的方法。

#### 2. 什么是日志管理？

日志管理，顾名思义，就是管理我们基础设施和应用产生的所有日志的一种实践。具体细节参考这本电子书[Log Management & Analytics – A Quick Guide to Logging Basics](https://sematext.com/resources/log-management-analytics-a-quick-guide-to-logging-basics-ebook/)。


日志管理可以分解为如下几个步骤或者注意点：

- 日志的聚合与传输：这一步主要是将分散在各个服务器上的日志收集到一个统一的日志中心。
- 日志存储与归档：这需要我们制定并实施日志的长期存储策略以及日志过期删除策略。
- 日志的质量保证：可以通过丢失条目寻址、异步时间戳、冗余日志等方式来保证数据的正确性。
- 日志的安全性和隐私性：日志中可能包含敏感数据，要避免泄露。关于这一点可以参考这篇文章[日志收集的 5 项最佳实践](https://sematext.com/blog/gdpr-top-5-logging-best-practices/)。
- 日志完善：可以根据需要向日志中添加数据，使我们可以明确知晓日志的上下文，具体细节客户以参考[The New Version of Logagent Enriches Container Logs with Metadata and GeoIP](https://sematext.com/blog/new-version-of-logagent-enriches-container-logs-with-metadata-and-geoip/)。
- 日志分析

对于日志的操作取决于多个因素，比如所要管理的日志量、应用的架构（对于分布式架构的应用，日志的管理操作也会相对复杂），而对于混合架构的应用，如何保证日志在云端和内部环境之间安全的传递移动也是必须要考虑的事情。另外不同类型的服务产生的日志量也会有所不同，对于 ServerLess 类型的服务，可能只会产生很少的日志；而对于本地数据中心则可能会产生大量的数据。


#### 3. APM 与日志管理的比较

一句话总结其关系：

- 有效的日志收集、管理、分析是实现可靠 APM 的根本保证。

但是日志管理并不仅仅只能用来作为实现 APM 的手段，其还可以支持实现其他目标，例如保护敏感数据、构建审计跟踪、生成合规报告以及帮助我们识别某些 APM 中没有展示出的应用变化趋势。

综上所述，没有完备的日志管理，APM 就缺少关键的数据源，导致其难以发挥作用。没有 APM 则无法对应用的运行情况做明确的监控以及解决频发的问题。因此为了充分保证应用的可用性，我们一般需要同时构建 APM 和 日志管理系统。

### 三. Tips
### 四. Share
