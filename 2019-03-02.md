### 一. Algorithm

做了 [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)。查找有序数组中的最小值，该数组可能是围绕某个节点旋转过，比如：

```
[0,1,2,4,5,6,7] > [4,5,6,7,0,1,2]
```

### 二. Review

### 三. Tips

分享一个 chrome 插件：[Octotree](https://github.com/ovity/octotree)，可以帮助我们在用 Chrome 看 Github 上的项目时展示其项目结构，示例如下：

没有安装插件时，查看 Github 项目时只能看到最上层的目录，

![](https://github.com/zouyingjie/arts/blob/master/image/arts_36_02.png)


安装插件之后，在 侧边就可以像在 IDE 中那样查看整个项目的结构，快速查看想要的文件了：

![](https://github.com/zouyingjie/arts/blob/master/image/arts_36_01.png)

### 四. Share

最近在看《Java 并发编程实战》书籍和极客时间的《Java 并发编程实战》专栏，看到关于死锁的部分。发现包括书籍在内的很多资料，都是简单讲解什么是死锁，然后就是给出一些可行的解决方式，比如

- 所有线程以固定的顺序获取锁
- 支持定时的锁

但是专栏中先提到了死锁发生需要满足的条件，然后在基于条件讲解决方案。对于死锁，仅满足下面四种情况时才会发生：

- 互斥
- 占有且等待
- 不可抢占
- 循环等待

那么只要破坏了上面任何一个就可以避免死锁了，基于这个在回头看书中提到的几种方式

- 以固定的顺序获得锁。这是破坏了第四种，避免了互相等待
- 定时锁。破坏了不可抢占，通过主动释放锁使其可以被抢占

另外基于第二种就是不让其等待了，可以通过一次性获取所有资源的方式来避免等待。

通过了解造成死锁的四个条件，然后针对引发问题条件在给出合适的解决方案。因为事先做到了知其所以然，后续的方案都做到了有的放矢，这样比单纯记住如何解决死锁要更加的令人印象深刻，遇到死锁问题时，排查思路也会更加的清晰。所以说学习知识，解决问题一定不要囿于表面，深入的理解原理和造成问题的原因，解决问题就不过是水到渠成的事情了。

另外一点就是对知识的高度总结、凝练。其实上面的四种情境在书中举得例子中是有所体现的，只不过没有像专栏中提炼的那么简洁而已，但是我们无法指望所有的知识都有人进行高度简洁的总结之后再去学习，因此在日常学习中一定要加强自己对知识的梳理、总结能力，穿过一个个的知识点，认识到背后的原理和联系，从而构建自己的知识体系，虽然这样做在一开始学习时会非常的慢，但随着知识点的不断积累和关联，学习的速度和深度会变得越来越快，形成一个正向的加速度，而不是单个知识点的记了忘，陷入狗熊掰棒子的囧境。