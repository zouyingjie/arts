### 一. Algorithm

继续做「打家劫舍」相关题目，这次做了 [337. House Robber III
](https://leetcode.com/problems/house-robber-iii/)，做题总结博客在这里 [LeetCode-337. House Robber III-简记](https://www.zouyingjie.com/post/-LeetCode337.-House-Robber-III%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/)。

### 二. Review

读 Medium 上的一篇文章:[The Differences Between a Junior, Mid-Level, and Senior Developer](https://medium.com/better-programming/the-differences-between-a-junior-mid-level-and-senior-developer-bb2cb2eb000d)。 简单介绍了高级工程师与初中级工程师的区别。下面为文章概要：

---

初中高级工程师之间的差距与工作年限没有太大的关系，一切取决于技能。虽然高级工程师并不一定什么都会，但总体而言其技能要比初中级工程师更加的熟练。除了编码技能之外，高级工程师在其他方面也有优于初中级工程师的地方，如下：

#### 1. 知识

高级工程师掌握了更多的知识点，比如设计模式、架构、自动化测试、性能与安全等对于初级开发人员，通过不断学习积累知识点，是初中级工程师拉近与高级工程师的距离最快捷的方式。

#### 2. 编码

编码本质是人与人之间的沟通，因此我们编写的代码必须有一定的质量保证，这样可以方便其他人阅读。编码质量和可读性是区分初级工程师和高级工程师的一个重要标准。

***初级工程师容易犯的错误***

初级工程师容易陷入一种 「炫技」的状态，可能会采用某些奇怪的代码或者复杂的抽象来编写代码。其更加关注代码的计算机层面的技巧而忽视了人这一层面的考量，导致写出来的代码其可读性可能不是很好。

***高级工程师的做法***

高级工程师编写简单、直接的代码。代码简洁直观是开发人员编程时可以拥有的最大品质之一。高级工程师更多的考虑代码的可维护性和伸缩性。

> 高级工程师考虑让代码适用于阅读它的人，而初级工程师只是考虑让它适用于计算机。

#### 3. 其他技能

这一部分文章主要集中在了解决问题方面：

- 高级工程师善于提出正确的问题并寻找合适的方式解决问题。
- 高级工程师不会迷失。他们可以通过思考，请教其他领域的人来解决问题。

初级工程师应该学着尽快积累经验，增加知识储备，达到中级工程师之后要学着提出正确的问题，并尽力解决它。

#### 3. 如何进阶

##### 【1】初级到中级

初级工程师最欠缺的就是经验，因此要尽可能的经历几个软件开发周期来积累经验，遇到并解决问题。在开发代码的过程中，应该尽可能保持代码的简洁，时刻想到会有别人开发人员来接手自己的代码。另外就是学会调试自己的代码，这样可以帮助自己更好的理解代码的执行过程。


##### 【2】 中级到高级 

文中提到从中级到高级是一个更难的过程，大部分工程师的整个职业生涯都停留在了中级工程师的水平上。 高级开发人员知道系统中哪些地方可以砍的，哪些地方应该改善。这些一般都是从过往经验中获得的教训。

如果你想成为高级工程师，那么你要做的就不应该仅仅是完成工作，而是要接受更大的挑战，时刻准备承担那些没有人知道解决方案的问题。

综上，成为高级工程师可以归纳为下面两点：

- 不断学习，积累大量的知识与经验
- 接收更多的挑战，去解决其他人不能解决的问题

### 三. Tips

Kafka 保证消息可靠性的两个方法。这里的可靠性是尽可能保证 Kafka 数据被正常发送和消费。

#### 1. 生产端 acks 确认

Kafka 的消息传输机制是消息先到达 leader 副本，然后在同步给其他的 follower 副本。如果某条在消息传输到 leader 副本之后，同步到 follower 副本之前，leader 副本挂掉，那么这部分的消息数据就有丢失的可能。为了确保消息一定传输到 broker，可以将设置 producer 的 ``acks=-1``，默认值是 1，表示传到 leader 副本就代表发送成功。而设置为 ``-1`` 表示必须等到消息同步到所有 follow 副本之后才算发送成功。

#### 2. consumer 手动提交偏移量

Kafka 的 consumer 采用拉的形式，每次 poll 一定量的消息进行消费，消费完成后将消费偏移量提交给 broker，默认情况下这种提交是自动的，比如下面的代码：

```Python
    
consumer = KafkaConsumer(
    bootstrap_servers="0.0.0.0", 
    api_version=(0, 10), 
    group_id=MY_GROUP
    )

consumer.subscribe(topics=[TP01, TP02])

for msg in consumer:
    process_msg(msg)

```

默认情况下，Consumer 会根据 ``auto_commit_interval_ms`` 配置项设置的时间间隔，默认是 5s，从 broker poll 消息进行消费，然后进行偏移量的提交。如果在消费过程中出现问题，导致某些消息没有被消费，那么这条消息也是丢失的。自动提交会带来重复消费和消息丢失的情况，因此在对可靠性要求较高的系统中，需要将 ``enable.auto.commit`` 参数设置为 ``false`` 执行手动提交。总体遵循如下原则：

> 如果消息没有被消费成功，那么就不能提交对应的偏移量
> 对于要求消息高可靠的系统，宁愿重复消费也不应该因为消费异常而导致消息丢失。


### 四. Share

第 52 期了，写了一篇 [ARTS 周年记](https://mp.weixin.qq.com/s/tnTLak470dpBYfiRjimCwQ)，总结了下自己做 ARTS 的问题得失和接下来的改进，欢迎交流拍砖。