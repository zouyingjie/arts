### 一. Algorithms
本周做的题目是 [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/description/) 

看到题目的第一眼是懵逼的。啥？不就是查看数组中某个值的索引嘛，没有就返回 -1。一个循环搞定妥妥的。于是就有了下面这段代码。

```
class Solution {
    public int search(int[] nums, int target) {
         for (int i = 0; i < nums.length; i ++) {
            if (nums[i] == target) {
                return i;
            }
        }
        return -1;
    }
}
```

写完后的运行效率 ***runtime beats 91.75 %***。 看起来还不错的样子。然鹅，作为一个 medium 难度的题目，不用大人看了，此事并没有那么简单。回到题目, 其有个要求，是log(n)。而第一版的算法，随着数量的增长，极端情况下，每次都要进行 N 次比较。性能是 O(n)。怎么降到 log(n) 呢，第一想到的就是二分查找啦。但这个普通的二分查找不同，给的数组有可能是转换过的，可能是两段有序的数组。因此首要先要找出转换的轴点，比如 [4,5,6,7,0,1,2] 的轴点是 0 ，其索引是 4。在这之前和之后都是一个有序的数组。可以使用二分查找。因此一次查询可能需要两次 2 分查找。其时间性能的  O(2logN)。满足要求。代码如下:

```
```

### 二. Review

本周读了耗子哥在推荐的微软云平台 Azure 上的设计模式系列文章，其中也有一篇介绍边车 (SideCar) 模式的，正好结合耗子哥专栏中的文章一起阅读。

简单来说，边车模式最主要的功能就是将主应用业务逻辑无关的功能分离解耦，作为一个单独的服务来使用。应用往往需要一些业务之外的功能，比如监控、日志、配置，网络服务等。 这些服务主要是两种实现:

*  嵌入到应用中。好处是共用资源，开放管理方便。坏处是依赖于业务应用的语言平台，并且一旦其中一个有问题可能会影响到其他功能。
*  作为服务剥离出现单独提供服务。好处是语言平台无关，并且服务之间互不影响。坏处是功能的使用变成了进程间调用，会有一定的延时，并且会增加部署管理的复杂性。

本质上还是针对应用的解耦作的一种 trade-off。



### 三. Technique


### 四. Share

