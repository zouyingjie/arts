### 一. Algorithm

本次做了 [154. Find Minimum in Rotated Sorted Array II](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/)，尝试的一道 Hard 题目，是上一期做的 [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)的进阶版本，在一个正序、元素可重复并且可能围绕某个节点做旋转的数组中查找其最小值。

示例数组如下：

```Java
[2, 2, 2, 0, 1]
[1, 3, 1, 1, 1]
[1, 1]
```

最简单粗暴的方式就是排序后去最小值了，代码为：

```Java
```

但这样效率很低，在上一题目中分析过， 旋转后的数组有如下特点：

> [4,5,6,7,0,1,2]
> 最小值左侧为升序，右侧为降序，并且升序部分中的值大于降序部分的值

但是因为重复元素的存在，可能导致上述特点不成立，比如：

```Java
[1, 3, 1, 1, 1]
```

这样，首先要保证的是数组满足上面特点，方式就是进行二分查找时将 max 移到小于最左侧元素的索引上：

```Java
int min = 0;
int max = len - 1;

         
while (min < max) {
    if (nums[min] == nums[max]) {
        max --;
    }else {
        break;
    }
}
```

完成后就可以使用之前的二分查找的规则了：


- 如果 nums[min] 小于 mid 值，此时 mid 位于升序部分，最小值在 mid 右侧
- 如果 nums[min] 大于 mid 值，此时 mid 位于降序部分，最小值在 mid 左侧

另外需要注意的一点是，min 和 mid 相等时可能只是因为重复元素的原因，而不是找到了最大或者最小值，因此还需要做一次处理

```Java
while (min < len -1) {
    // 如果是重复元素，则继续移动 min
    if (nums[min] == nums[min + 1]) {
        min ++;
    }else {
        mid = (min + max) / 2;
        break;
    }
}
```

完整代码如下：

```
class Solution {
     public int findMin(int[] nums) {
        int len = nums.length;
        if (len == 1) {
            return nums[0];
        }

        int min = 0;
        int max = len - 1;

        while (min < max) {
            if (nums[min] == nums[max]) {
                max --;
            }else {
                break;
            }
        }

        if (min > max) {
            return nums[min];
        }
         
        if (nums[min] < nums[max]) {
            return nums[min];
        }

        int mid = (min + max) / 2;
        while (min < max) {
            if (nums[min] <  nums[mid]) {
                min = mid;
                mid = (min + max) / 2;
            }else if (nums[min] > nums[mid]){
                max = mid;
                mid = (min + max) / 2;
            }else {
                if (min > 0 && nums[min-1] > nums[min]) {
                    break;
                }else if (min < len -1 && nums[min] > nums[min+1]){
                    break;
                }

                while (min < len -1) {
                    if (nums[min] == nums[min + 1]) {
                        min ++;
                    }else {
                        mid = (min + max) / 2;
                        break;
                    }
                }
            }
        }

        if (min < len -1) {
            if (nums[min] > nums[min + 1]) {
                return nums[min + 1];
            }
        }
        return nums[min];
    }
}
```

### 二. Review

### 三. Tips




### 四. Share


分享下自己最近工作、学习时采用的抗干扰、分心的方法吧，感觉是自己体验过的最有效的方式了：

> 消息免打扰 + Bose 隔音降噪耳机 + 潮汐白噪音

不知道大家在自习的时候有没有遇到各种效率问题，包括但不限于：

- 本来计划好的各种事情，当你坐下来开始干的时候脑子就开始各种奇奇怪怪的想法飘过，导致不想学习干活
- 动不动就刷个朋友圈、微博，导致时间碎片化
- 微信消息等通知的骚扰
- 没有注意到的分神：比如听歌。虽然程序员大部分都会边听歌边敲代码，但我再实际观察自己的状态时，发现当听歌的时候大脑总会有一个后台线程去跟着歌的旋律来哼哼，听歌线程活跃了，当然就影响主线程的性能了。

将干扰元素分为主动干扰和被动干扰两种：

- 微信、短信等手机通知，他人主动或者交谈时被动的打扰，这些为被动
- 胡思乱想、动力不足、没事看手机这些可以视为主动干扰

为了解决被动干扰采用两条：

- 在自习或者需要完成大块任务时，主动断网，或者开启免打扰模式，这样可以保证不被微信消息等各种消息中断
- Bose 降噪耳机，可以将周围的声音降到非常低，一戴上世界都安静了，可以屏蔽现实世界被动的干扰，比如各种噪音等

然后就是主动干扰，学习是逆人性的，尤其面对高难度的知识时，内心将会冒出无数个让你放弃的理由。此时最重要的是两点：

- 明确学习目标和动力
- 营造合适的学习氛围

第一点无需多讲了，每个人都不缺乏坐下来打算好好学习的动力，但动力只是开始，更重要的是怎样将学习状态保持好，这就需要营造适合自己的学习氛围了。
自己最有效的方式是

- 戴上降噪耳机，然后听白噪音，尤其是雷雨声音的白噪音。
- 晚上的话会关闭大灯，只开台灯，并将灯光调为偏黄色

结合 Bose 降噪耳机，将周围世界的声音屏蔽掉，几乎只能听见雷雨的声音，想象一下，清明时节雨纷纷，你坐在咖啡馆翻开一本书悠然自得的读者，世界与你归于寂静，这种时候不学习是不是有点过意不去，哈哈。

自己最近通过这种方式，整个自习时的效率还是提高了不少的，可以比较快速、长时间的沉浸在学习中，也就是所谓的心流状态，有和我一样自习时会走神、动不动看手机、分心的同学不妨可以参考下。