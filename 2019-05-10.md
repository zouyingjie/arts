### 一. Algorithm

继续做买卖股票系列题目，本次是 [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)。

和第一道题目不同，题目一求的是在一次交易中可以获取的最大值，而题目二可以多次交易，但在买入前必须把手中的先卖掉，求其最大收益值。

该题目就不能像第一题那样简单的找整个数组的最大差值，而是求各个波段的最大差值。也就是说，买入一只股票后，我们最要在其升值波段的最高点卖掉，比如

> [7,1,5,3,6,4]，在索引为 1 的价格买入后，其升值波段的最高点为 5，那么就要在这里卖出，然后在下一个低点继续买入，最终基于各个波段的收益和求出最大收益。

那么在第一题遍历的基础之上，要做的就是当前值与最小价格的差值是否为当前波段的最大收益，如果是，更新当前波段的最大收益，不是，则将当前波段的最大值加到最终收益中，然后将当前值作为新的买入低点，继续遍历。代码如下：

```Java
class Solution {
    public int maxProfit(int[] prices) {
     int len = prices.length;
        if (len <= 1) {
            return 0;
        }

        int result = 0;
        // 当前波段最大收益
        int currentProfit = 0;

        int lowestPrice = prices[0];

        for (int i = 1; i < len; i ++) {
            int num = prices[i];
            if (num > lowestPrice) {
                int profit = num - lowestPrice;
                if (profit > currentProfit) {// 波段继续上涨中，更新当前波段最大收益
                    currentProfit = profit;
                    if (i == (len-1)){ // 已经遍历到最后时要把当前波段收益加到最终受益中
                        result += currentProfit;
                    }
                }else { // 当前波段开始下跌了，将波段收益加到最终结果，更新买入低点
                    result += currentProfit;
                    currentProfit = 0;
                    lowestPrice = num;

                }
            }else { // 新的低点，重新买入
                result += currentProfit;
                currentProfit = 0;
                lowestPrice = num;
            }
        }
        return result;
    }
}
```

依然需要完整的遍历数组，时间复杂度为 O(N)，消耗空间为数组空间，因此空间复杂度为 O(N)。和第一题是一脉相承的，把第一题想清楚了第二题也挺容易想明白的，最需要的就是当波段下降时一定将波段收益加到总收益中，避免漏掉计算。

### 二. Review

读了微软 Azure 分布式系统设计模式系列文章可用性主题的第二篇文章:[Queue-Based Load Leveling pattern(基于队列的负载均衡模式)](https://docs.microsoft.com/en-us/azure/architecture/patterns/queue-based-load-leveling)。

主要讲解了在分布式系统中，通过消息队列中间件来实现对任务的削峰，避免因为短时间内任务过多导致服务不可用的情况出现。下面是文章的内容概要：

#### 1. 问题由来

在分布式系统中，经常有一些任务需要调用某些服务，随着时间的变化，任务的数量是变化的，这种情况可能会对系统的可用性和稳定性产生影响。

服务和任务可能隶属于同一个应用，也可能是第三方的服务，比如缓存、数据存储等服务，被许多个应用使用。如果存在一个服务可能被多个应用或任务访问的情况，那么预测服务所要承受的负载是一件比较困难的事情。

服务可能会遇到请求高峰，导致服务系统过载从而无法及时的响应请求，响应不及时可能又会造成调用方的资源争抢，进一步提高了并发量，从而导致服务被限流甚至崩溃，严重影响可用性。


#### 2. 解决方案

为了解决上述问题，一种方案是引入消息队列中间件，使得任务的发布和任务的执行解耦，变成异步操作。任务方发送一条消息给消息队列，消息中包含了执行任务所需要的数据，消息队列扮演缓冲的角色来存储消息，服务方从消息队列获取消息并执行相应的任务。不同任务方以不同的速率产生任务，但通过消息队列可以以一种恒定的速度传输给任务执行方，整体架构如图：

![](https://docs.microsoft.com/en-us/azure/architecture/patterns/_images/queue-based-load-leveling-pattern.png)

如图所示，通过消息队列实现了任务方和服务方的解耦，无论任务方的任务产生速度如何，服务方始终以较为稳定的速度来处理任务。该模式有如下好处：

- 可以最大程度的提高系统的可用性。即使服务方不可用，任务方依然可以不停的向消息队列中发送消息，避免因服务方不可用引起的系统崩溃。
- 可以提高系统的伸缩性。任务方和服务方都可以基于需求做水平伸缩
- 帮助节省成本，服务方只需要满足平均任务负载而不是负载峰值的配置即可


#### 3. 问题与思考

使用该模式时，有下面几个问题需要注意：

- 需要编写消息的消费速率控制逻辑，使得服务方能以一个稳定的速率消费消息，避免因为发布消息过多，将并发压力传递到了服务方，导致服务不可用。要注意测试正式环境下的平均负载，然后提供合适的队列和服务实例来保证足以支撑该负载。

- 消息队列是一种单向的通信机制，如果任务方需要知道任务的执行结果的话，可能需要额外的机制向任务方发送响应，可以参考 [Asynchronous Messaging Primer（异步消息入门）](https://msdn.microsoft.com/library/dn589781.aspx) 这篇文章。

- 如果服务方使用了自动扩容机制，那么需要注意该机制导致的服务方争用消息队列资源从而降低了消息队列负载有效性的情况，

#### 4. 使用时机与示例

该模式的使用规则非常简单：

- 任何需要流量削峰的地方都可以考虑采用消息队列来实现
- 如果应用对服务的执行延迟要求降到最小，那么此时应用是采用同步的方式，不适合使用消息队列进行异步操作。

下面的文中的一个示例，多个示例同时调用存储服务，导致服务负载过大出现不可用的情况：

![](https://docs.microsoft.com/en-us/azure/architecture/patterns/_images/queue-based-load-leveling-overwhelmed.png)

如果采用消息队列来削峰，则可以避免存储服务被限流、降级或者直接不可用，架构如图：

![](https://docs.microsoft.com/en-us/azure/architecture/patterns/_images/queue-based-load-leveling-function.png)

如图所示，通过一个 function app 来控制消息的消费速率，其不断访问数据存储服务实现存储，避免了以为流量过大导致的服务不可用的情况。

### 三. Tips

分享下最近看的一篇关于 ES 的文章：[你头疼的ELK难题，本文几乎都解决了](https://mp.weixin.qq.com/s?__biz=MzA4Nzg5Nzc5OA==&mid=2651677255&idx=1&sn=2133c74a2243068efde242dadf059777) ，介绍了 ELK 使用中一些非常有用的技巧，比如

- Logstash 的配置优化
- ES 优化
- 日志的多行处理
- 字符问题
- 性能检测 

这些都是现实使用 ES 中经常遇到的问题，本篇文章做了很好的总结，希望对需要的同学有所帮助。


### 四. Share

最近读得到《刘润五分钟商学院》中一篇关于时间颗粒度的文章：

> 时间颗粒度，就是一个人管理时间的基本单位。有的人是半小时，有的人是 15 分钟，有的人是 5 分钟。

> 随着一个人越来越成功，其时间也会越来越值钱，其时间颗粒度也会越来越细。

个人觉得时间颗粒度是事务颗粒度的直观体现，对于一些碎片化或者不需要长时间专注的事情，小的时间颗粒度可以提高我们完成事情的效率，避免拖延。而对于写作、编程、设计等事情，可能就需要比较长的时间颗粒度。当然对于编程而言，我们也可以将要做的事情逐步分解细化，每个小步骤代表一个小的时间颗粒度。当你的时间颗粒度划分到比较小之后，可能也意味着的你对整个要做的事情已经想的比较明白，将完成任务所需要的每个步骤完全细化明确了。因此：

- 细化时间颗粒度的关键是细化并明确自己要做的事情，小任务限时，大任务拆分，然后在一小段时间内专注完成当前时间粒度内要完成的事情。