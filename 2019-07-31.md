### 一. Algorithm

做了一道很简单的题目：[509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/)，题目要求很明白，就是按照斐波那契数列求值。

斐波那契数列公式如下：

```
F(0) = 0
F(1) = 1
F(N) = F(N-1) + F(N-2)
```

基于公式可以很简单的得出答案，代码如下：

```Java
class Solution {
    public int fib(int N) {
        if(N == 0) {
            return 0;
        }
        
        if(N == 1) {
            return 1;
        }
        
        return fib(N-1) + fib(N-2); 
    }
}
```

上面是标准基于斐波那契数列公式递归求解的代码，但是这种解法有问题：

- 如果数字 N 很大，可能会导致 StackOverflowError
- 重复计算，比如 F(5) = F(4) + F(3)，而计算 F(4) 时又会计算一遍 F(3)。

因此上面的算法是需要优化的，递归一般可以转为遍历操作。我们已经知道了 F(0) 和 F(1) 的值，那么可以很自然的求出 F(2)、F(3)...F(N) 的值。代码如下，通过遍历的方式避免了重复计算和栈溢出的问题。

```Java
class Solution {
    public int fib(int N) {
        
        if(N == 0) {
            return 0;
        }
        
        if(N == 1) {
            return 1;
        }
        
        int[] nums = new int[N+1];
        nums[0] = 0;
        nums[1] = 1;
        
        for(int i = 2; i <= N; i ++) {
            nums[i] = nums[i-1] + nums[i-2];
        }
        return nums[N];
    }
}
```

上面就是解题过程，虽然简单却是许多题目的解题方法原型。许多动态规划的题目都可以归结为上面的思路，比如爬楼梯、House Robber、Unique BST 等动态规划的题目。

### 二. Review
### 三. Tips
### 四. Share
